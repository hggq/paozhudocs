<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>PaoZhu C++ Web Frameworks</title>
    <style>
        /* Light mode */
        body {
            font-family:'PingFang SC','Helvetica Neue','Microsoft YaHei UI','Microsoft YaHei','Noto Sans CJK SC',Sathu,EucrosiaUPC,Arial,Helvetica,sans-serif;
            font-size:16px;
            line-height:1.45em;
        }
        code{
            background-color: #EEE;
            border-radius: 5px;
            padding: 3px;
        }
        @media (prefers-color-scheme: light) {
        body {
            color: black;
            background-color: white;
            font-size: 14px;
        }
        body pre {
            padding: 5px;
            overflow: auto;
            line-height: 1.45em;
            background-color: #EEE;
            border-radius: 6px;
        }
 
        body pre {
            word-wrap: normal;
        }
        body pre > code {
            padding: 0;
            margin: 0;
            word-break: normal;
            white-space: pre;
            background: transparent;
            border: 0;
        }
 
        body pre > code {
            white-space: pre-wrap;
        }
        code{
            background-color: #EEE;
            border-radius: 5px;
            padding: 3px;
        }

        }

        /* Dark mode */
        @media (prefers-color-scheme: dark) {
        body {
            color: white;
            background-color: black;
        }

        body pre {
            padding: 5px;
            overflow: auto;
            line-height: 1.45em;
            background-color: #333;
            border-radius: 6px;
        }
 
        body pre {
            word-wrap: normal;
        }
        body pre > code {
            padding: 0;
            margin: 0;
            word-break: normal;
            white-space: pre;
            background: transparent;
            border: 0;
        }
 
        body pre > code {
            white-space: pre-wrap;
        }

        code{
            background-color: #333;
            border-radius: 5px;
            padding: 3px;
        }
        }

        @media (min-width: 1200px) {
            .container {
                width: 1080px;
                margin: 0 auto;
            }
        }
    </style>

</head>

<body>
    <h1 style="text-align:center;">PaoZhu C++ Web Frameworks</h1>
    <h4 style="text-align:center;"><a href="documentation.html">中文</a> <a href="documentation_en.html">English</a></h4>
    <div class="container">
        <h3><strong>简介</strong></h3>
        <p>paozhu是一款C++ Web开发框架，内置HTTP/1 HTTP/2 ORM,可以轻松优雅写Web程序，打破以往C++写Web程序不方便问题。</p>
        <p>paozhu编写了Web开发底层设施，比如多域名绑定、SSL证书管理、Cookie、Session、HTML表单管理 、URL处理、文件上传下载、HttpClient客户端、数据库连接ORM、WebSocket、日志，涵盖Web开发基础。</p>
        <p>框架基于C++20为基础，一个是使用新标准，编译器支持完整，一个是让代码更加现代化，框架开启了ASAN和所有错误提示，方便开发阶段发现问题，也可以运行时候结合coredumpctl工具，查看各个线程内存栈。配合智能指针基本杜绝内存泄露和越界问题，框架目前基本没有碰到内存泄露或崩溃情况。</p>
        <p>paozhu使用C++，主要是考虑接入大模型（CUDA、文件存储、网络、内存操作）、对比下GO JAVA RUST，都不是很完美，C++也不完美，RUST语法不好看、GO简单但是大模型等没有很深厚文化。目前经验是ASAN和coredumpctl两个工具也能保证C++质量，新编译器也能提示一部分。</p>
        <h3>paozhu特色</h3>
        <ol>
        <li>支持HTTP2。</li>
        <li>内置ORM（自研MySQL协议），支持协程模式。</li>
        <li>多域名管理、SAAS模式支持。</li>
        <li>IO线程和业务线程分开。</li>
        <li>内置微型对象，JSON导入导出，类似脚本语言中变量。</li>
        <li>内置FastCGI 支持PHP</li>
        </ol>
        </div>
        <div class="container">
        <h3>paozhu需求环境</h3>
        <p>paozhu支持<code>MacOS</code>、<code>Linux</code>、<code>Windows</code>系统。</p>
        <p>依赖第三方开发包</p>
        <p><code>OpenSSL</code> <code>Zlib</code> <code>Brotli</code> <code>ASIO</code></p>
        <p>可选第三方包</p>
        <p><code>GD</code> <code>qrencode</code></p>
        <p>框架基于C++20以上，确保你的系统支持的编译器支持C++20。</p>
        <ul>
        <li><code>MacOS</code> 必须<code>MacOS 11 BigSur</code>以上，最好是 <code>MacOS 14 Sonoma</code></li>
        <li><code>Ubuntu</code> 必须是22.04以上</li>
        <li><code>RockyLinux</code> <code>AlmaLinux</code> 必须是9.1以上</li>
        <li><code>Windows</code> 必须是Win10 编译器最好19.25以上。</li>
        </ul>
    </div>
    <div class="container">
        <h3>paozhu安装</h3>
        <p>到官方github库：<a href="https://github.com/hggq/paozhu" target="_blank">https://github.com/hggq/paozhu</a></p>
        <ul>
        <li><a href="macos.html" target="_blank">MacOS安装</a> 参考</li>
        <li><a href="ubuntu.html" target="_blank">Ubuntu安装</a> 参考</li>
        <li><a href="linux.html" target="_blank">RockyLinux AlmaLinux</a> 安装 参考</li>
        <li><a href="windows.html" target="_blank">Windows</a> 安装 参考</li>
        </ul>
        <h3>paozhu框架技术架构原理</h3>
        <p>paozhu框架使用了ASIO的线程池，是专门用来做IO使用，比如网络收发，框架也内置有一个业务线程池，专门用来运行业务代码的。</p>
        <p>目前框架主要HTTP和HTTPS，两个线程不断倾听连接到来，当用户使用浏览器或Client访问时候产生一个连接，握手后，服务器等待客户端发出HTTP头部信息，然后服务器处理器HTTP协议，如果URL匹配是注册函数，看函数是协程还是普通函数，协程直接运行，如果是普通函数直接丢到业务线程池，如果URL是静态文件，那么直接发送，不走业务线程。</p>
        <p>因为C++协程有传染性，所以你在协程注册函数里面运行业务代码时候，需要使用ORM协程方法，如果你在普通函数里面无法发起协程函数只能用ORM普通函数。
        一般建议使用一个连接一个线程，业务线程也是有队列的，所以业务代码不要随便使用sleep函数睡眠。</p>
    </div>
    <div class="container">
        <h3>paozhu配置</h3>
        <p>paozhu配置文件在<code>conf/server.conf</code></p>
        <p>可以先了解几个变量让项目运行起来。</p>
        <pre><code>[default]
        threadmax=1024
        threadmin=5
        httpport=80
        httpsport=443
        cothreadnum=8 ;Coroutines run on thread num
        
        http2_enable=1
        debug_enable=1
        deamon_enable=0
        mainhost=www.869869.com
        certificate_chain_file=www.869869.com.pem
        private_key_file=www.869869.com.key
        tmp_dh_file=dh4096.pem
        reboot_password=e10adc3949ba59abbe56e057f20f883e ;md5(md5(&quot;123456&quot;)+&quot;rand_char&quot;+md5(&quot;123456&quot;))
        reboot_cron =d180h5 ;MDSW+Hhours reboot process M month D day S season (1 4 7 10) W week  
        clean_cron  =m5t600 ;5-minute interval clean 600 seconds ago inactive connection
        links_restart_process =n9998877ts1te5 ;More than 15000 connections, restart the process from 1:00 am to 5:00 am
        session_type=1 ;session save type 0.file 1.memory 2.redis 3.memcache 4.reserve
        static_file_compress_cache=1 ;1 enable, Cache static file compress(gzip,br) content to cache directory 
        modelspath=/Users/hzq/paozhu/models
        serverpath=/Users/hzq/paozhu
        viewpath=/Users/hzq/paozhu/view
        viewsopath=/Users/hzq/paozhu/module/view
        
        controlpath=/Users/hzq/paozhu/controller
        controlsopath=/Users/hzq/paozhu/module/controller
        
        temppath=/Users/hzq/paozhu/temp
        logpath=/Users/hzq/paozhu/log
        wwwpath=/Users/hzq/paozhu/www/default
        pluginspath=/Users/hzq/paozhu/plugins
        libspath=/Users/hzq/paozhu/libs
        directorylist=1
        index=index.html
        ;usehtmlcache=1
        ;usehtmlcachetime=3600
        staticfile_cache_num=0 ;0 not cache, min 10 begin  
        rewrite_404=0   ;1 file 2 action url path
        rewrite_404_action=index.html
        method_pre=
        method_after=
        show_visitinfo=0
        upload_max_size=16777216
        siteid=1
        groupid=0
        alias_domain=
        init_func=
        [www.869869.com]
        wwwpath=/Users/hzq/paozhu/www/default
        http2_enable=1
        ;rewrite_404=1
        ;rewrite_404_action=index.html|psy/index.html|exam/index.html
        ;controlsopath=/Users/hzq/paozhu/docs/controller
        static_pre=downloadfileauth|upload
        method_pre= ;api/dev/hostcors
        method_after=
        isuse_php=0
        rewrite_php=/Users/hzq/www/mpdftest|index.php
        fastcgi_host=127.0.0.1 ;/run/php/php8.1-fpm.sock
        fastcgi_port=9000
        upload_max_size=16777216
        siteid=1
        groupid=0
        alias_domain=
        init_func=
        </code></pre>
        <pre><code>threadmax=1024  最大业务线程数
        threadmin=5		最小业务线程数
        httpport=80	    服务器倾听端口 
        httpsport=443   ssl服务器倾听端口 
        cothreadnum=8 ;Coroutines run on thread num IO协程使用线程池数量
        </code></pre>
        <p><code>http2_enable=1</code> 是否启用http2，可以每个域名有自己的设置</p>
        <p>ssl证书文件，申请成功后放在conf目录，生产环境需要在<code>/var/local/etc/paozhu</code>放一份</p>
        <pre><code>mainhost=www.869869.com
        certificate_chain_file=www.869869.com.pem
        private_key_file=www.869869.com.key
        </code></pre>
        <p><code>reboot_cron</code> 自动重启进程周期天D 周W 月M 季节S  h时间小时 180天凌晨5点重启进程
        <code>links_restart_process</code> 如果达到连接数也可以重启n后面连接数，
        ts 开始时段 te结束时段，如果这段时间空闲就会重启。</p>
        <pre><code>reboot_cron =d180h5 ;MDSW+Hhours reboot process M month D day S season (1 4 7 10) W week  
        clean_cron  =m5t600 ;5-minute interval clean 600 seconds ago inactive connection
        links_restart_process =n9998877ts1te5 ;More than 15000 connections, restart the process from 1:00 am to 5:00 am
        </code></pre>
        <p><code>directorylist=1</code> 显示目录，如果请求静态文件是目录名，目录下也没有index.html文件会显示目录列表。
        生产环境建议设置为0.</p>
        <p><code>wwwpath=/Users/hzq/paozhu/www/default</code> <code>/Users/hzq/paozhu</code>建议换成你的当前目录名称,
        项目下<code>www/default</code>，是静态文件目录，如果是多域名建议创建<code>www/domain.com</code>这个设置是为SAAS服务的。</p>
        <p><code>upload_max_size=16777216</code> 上传文件大小，默认是16M</p>
        <p>下面几个是SAAS设置可以先不管</p>
        <pre><code>siteid=1
        groupid=0
        alias_domain=
        init_func=
        </code></pre>
        <p>初学者只要关注 <code>httpport</code> <code>httpsport</code> <code>wwwpath</code> <code>logpath</code>设置是否正确,
            把所有<code>/Users/hzq/paozhu</code>换成你的目录。</p>
    </div>
    <div class="container">
        <h3>paozhu入门</h3>
        <h4>Hello, World 例子</h4>
        <pre><code class="language-C++">
        #include "techempower.h"    
        //@urlpath(null,plaintext)
        asio::awaitable&lt;std::string&gt; techempowerplaintext(std::shared_ptr&lt;httppeer&gt; peer)
        {
            peer-&gt;type(&quot;text/plain; charset=UTF-8&quot;);
            peer-&gt;set_header(&quot;Date&quot;, get_gmttime());
            peer-&gt;output = &quot;Hello, World!&quot;;
            co_return &quot;&quot;;
        }
        
        </code></pre>
    </div>
    <div class="container">
        <h3>注解原理</h3>
        <p>所有注解函数必须放在 <code>controller/src</code> 目录下</p>
        <p><code>techempower.cpp</code>文件必须包含自身文件名的头文件 <code>#include "techempower.h"</code> ，<code>techempower.h</code>这个文件会自动生成。</p>
        <p>编译时候使用CMake Hook，先编译一个可以使用的注解处理程序，然后执行这个程序处理  <code>controller/src</code>
        目录下所有文件，提取<code>//@urlpath(null,plaintext)</code>格式的函数，然后创建相应的头文件，然后生成
        注解函数，保存映射函数到 <code>common/autocontrolmethod.hpp</code> 文件。</p>
        <p>是不是很有Java Spring Boot味道，这样我们可以毕竟优雅写URL和函数映射关系。</p>
    </div>
    <div class="container">     
        <h3>注解介绍</h3>
        <p><code>//@urlpath(null,plaintext)</code> 为注解函数，与url映射，比如 http://localhost/plaintext 会访问到<code>plaintext</code> 的注解函数。</p>
        <p>null表示访问plaintext之前必须先执行的注解函数，例如：带权限的后台，需要验证是否登录</p>
        <p><code>//@urlpath(islogin,plaintext)</code> 这样必须先执行<code>islogin</code>的注解，返回<code>OK</code>表示成功。</p>
        <pre><code class="language-C++">//@urlpath(null, islogin)
        asio::awaitable&lt;std::string&gt; checklogin(std::shared_ptr&lt;httppeer&gt; peer)
        {
            httppeer &amp;client = peer-&gt;get_peer();
        
            if(peer-&gt;session[&quot;userid&quot;].to_int()&gt;0)
            {
                 co_return &quot;ok&quot;;
            } 
        
            client &lt;&lt; &quot;You must login&quot;;
        
            co_return &quot;&quot;;
        }
        </code></pre>
        <p><code>asio::awaitable&lt;std::string&gt;</code> 协程注解函数表示里面代码不走业务线程，
        如果繁重计算最好使用普通函数，这样走业务线程处理，不会卡IO线程。</p>
        <p><code>peer-&gt;session[&quot;userid&quot;]</code> 表示取得<code>session</code>内容，可以在登录成功后保存进去。</p>
        <p><code>client &lt;&lt; &quot;You must login&quot;;</code> 是重载了<code>&lt;&lt;</code>运算符,真实内容是保存在<code>peer-&gt;output</code>。</p>
        <p><code>co_return &quot;&quot;;</code> 是协程返回结果，请注意和普通函数区别，不知道最好返回空字符串。</p>
        <p>下面是普通注册函数,注意返回值，表示走业务线程池，就是一个连接分配一个线程，经典应用。</p>
        <p>建议有负载计算最好使用这种普通函数，不然大量计算可能影响并发量，是有可能，如果只是CRUD业务
        用那种方式应该问题不大，用协程就不要使用 <code>std::this_thread::sleep_for(std::chrono::microseconds(1000));</code>
        这种代码。</p>
        <pre><code class="language-C++">//@urlpath(null,hello)
        std::string testhello(std::shared_ptr&lt;httppeer&gt; peer)
        {
            httppeer &amp;client = peer-&gt;get_peer();
            client &lt;&lt; &quot; Hello world! 🧨 Paozhu c++ web framework &quot;;
        
            return &quot;&quot;;
        }
        
        </code></pre>
        <p>更多代码使用案例请参考 <code>controller/src</code> 目录下的例子</p>
    </div>
    <div class="container">
        <h3>内置微型对象介绍</h3>
        <pre><code class="language-C++">http::obj_val hval;
        hval[&quot;aaa&quot;]=3344;
        hval[&quot;bbb&quot;]=&quot;1234567890&quot;;
        
        std::cout&lt;&lt;&quot;ll:&quot;&lt;&lt;hval[&quot;aaa&quot;].to_int()&lt;&lt;std::endl;
        std::cout&lt;&lt;&quot;vv:|&quot;&lt;&lt;static_cast&lt;int&gt;(hval[&quot;bbb&quot;].get_type())&lt;&lt;&quot;|&quot;&lt;&lt;std::endl;
        if(hval[&quot;bbb&quot;].is_string())
        {
            std::cout&lt;&lt;&quot;str:&quot;&lt;&lt;hval[&quot;bbb&quot;].to_string()&lt;&lt;std::endl;
            std::cout&lt;&lt;&quot;str:&quot;&lt;&lt;hval[&quot;bbb&quot;].str_view()&lt;&lt;std::endl;
            std::cout&lt;&lt;&quot;str:&quot;&lt;&lt;hval[&quot;bbb&quot;].str_view(2,5)&lt;&lt;std::endl;
        }
        
        http::obj_val nval;
        nval.from_json(&quot;{\&quot;bba\&quot;:[[[111,222],[333,444],[555,666]],[[777,888],[999,1111],[2222,3333]],[[4444,5555],[6666,7777],[8888,9999]]]}&quot;);
        
        std::cout&lt;&lt;&quot;json out:&quot;&lt;&lt;nval.to_json()&lt;&lt;std::endl;
        
        std::string bbb=nval.to_json();
        http::obj_val pval;
        pval.from_json(bbb);
        </code></pre>
        <p><code>http::obj_val</code> 是框架内置一个微型对象，可以导入<code>from_json</code>和导出<code>to_json</code> <code>JSON</code>对象转换。</p>
        <p>是不是有脚本语言味道，可以保存数值和字符串，而且可以保存树形结构。</p>
        <p>一个<code>http::obj_val</code>是16个字节大小，如果是<code>KV</code>对象要64大小。</p>
        <p><code>hval[&quot;aaa&quot;]</code> 就是<code>KV</code>对象。</p>
        <p><code>http::obj_val</code> 对象内置方法</p>
        <ul>
        <li><code>set_array()</code> 设置为数组 可以使用push(v)</li>
        <li><code>set_obj()</code> 设置为对象KV 可以使用push(k,v)或obj[key]=value方式</li>
        <li><code>set_object()</code> 设置为对象KV 可以使用push(k,v)或obj[key]=value方式</li>
        </ul>
        <h4>判断对象属性</h4>
        <ul>
        <li><code>is_array()</code> 是否是数组</li>
        <li><code>is_obj()</code>	是否是对象</li>
        <li><code>is_object()</code> 是否是对象</li>
        <li><code>is_string()</code> 是否是字符串</li>
        <li><code>is_number()</code> 是否数字</li>
        </ul>
        <h4>典型使用方式和HTML模板使用</h4>
        <pre><code class="language-C++">        client.val[&quot;list&quot;].set_array();
                obj_val temp;
        
                for (unsigned int i = 0; i &lt; topicm.record.size(); i++)
                {
                    temp[&quot;id&quot;]       = topicm.record[i].topicid;
                    temp[&quot;parentid&quot;] = topicm.record[i].parentid;
                    temp[&quot;value&quot;]    = topicm.record[i].title;
                    client.val[&quot;list&quot;].push(temp);
                }
        </code></pre>
    </div>
    <div class="container">
        <h4>在HTML模板中使用</h4>
        <pre><code class="language-HTML">&lt;%c for(auto &amp;a:obj[&quot;infos&quot;].as_array()){ %&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;%c echo&lt;&lt;a[&quot;userid&quot;].to_string(); %&gt;&lt;/td&gt;
          &lt;td&gt;&lt;%c echo&lt;&lt;a[&quot;nickname&quot;].to_string(); %&gt;&lt;/td&gt;
          &lt;td&gt;&lt;%c echo&lt;&lt;a[&quot;name&quot;].to_string(); %&gt;&lt;/td&gt;
          &lt;td&gt;&lt;%c if(a[&quot;isopen&quot;].to_int()==1){ %&gt;启用&lt;%c }else{ %&gt;关闭&lt;%c } %&gt;&lt;/td&gt;
          &lt;td&gt;&lt;a href=&quot;/superadmin/edituser?userid=&lt;%c echo&lt;&lt;a[&quot;userid&quot;].to_string(); %&gt;&quot;&gt;编辑&lt;/a&gt; | &lt;a href=&quot;/superadmin/deleteuser?userid=&lt;%c echo&lt;&lt;a[&quot;userid&quot;].to_string(); %&gt;&quot; onclick=&quot;return confirm('确定删除？');&quot;&gt;删除&lt;/a&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;%c } %&gt;
        </code></pre>
        <h4>内置微型对象高级方法</h4>
        <ul>
        <li><code>obj_val multi_sort(std::string_view key,unsigned char order);</code> 二维数组按键名排序 order 可以是 SORT_ASC,SORT_DESC</li>
        <li><code>obj_val multi_sort(std::string_view key,unsigned char order,std::string_view key2,unsigned char order2);</code>	二维数组按键名排序 order 可以是 SORT_ASC,SORT_DESC，如果有相同二次排序,需要key2 和 order2</li>
        </ul>
        <h4>内置微型对象高级用法</h4>
        <pre><code class="language-c++">    http::obj_val zval4;
            zval4.set_array();
            float s[6]={83.3,77.75,60.45,83.3,77.75,45.6};
            for(unsigned int jjj=0;jjj&lt;6;jjj++)
            {
                http::obj_val z4;
                z4.set_object();
                z4[&quot;name&quot;]=&quot;sss&quot;+std::to_string(jjj);
                z4[&quot;score&quot;]=s[jjj];
                z4[&quot;id&quot;]=jjj+10;
                zval4.push(z4);
            }
            http::obj_val zval5=zval4.multi_sort(&quot;score&quot;,SORT_ASC);

            std::cout&lt;&lt;&quot;------&quot;&lt;&lt;std::endl;
            if(zval5.is_array())
            {
                std::cout&lt;&lt;&quot;multi_sort score result: &quot;&lt;&lt;zval5.size()&lt;&lt;std::endl;
                for(auto &amp;a:zval5.as_array())
                {
                    if(a.is_object())
                    {
                        for(auto &amp;[aa,bb]:a.as_object())
                        {
                            std::cout&lt;&lt;&quot;zval5[&quot;&lt;&lt;aa&lt;&lt;&quot;]=&quot;&lt;&lt; bb.to_string()&lt;&lt;std::endl;
                        }
                    }
                    std::cout&lt;&lt;std::endl;
                }
            }

            http::obj_val zval6=zval4.multi_sort(&quot;score&quot;,SORT_ASC,&quot;id&quot;,SORT_DESC);
            std::cout&lt;&lt;&quot;------&quot;&lt;&lt;std::endl;
            if(zval6.is_array())
            {
                std::cout&lt;&lt;&quot;multi_sort score id result: &quot;&lt;&lt;zval6.size()&lt;&lt;std::endl;
                for(auto &amp;a:zval6.as_array())
                {
                    if(a.is_object())
                    {
                        for(auto &amp;[aa,bb]:a.as_object())
                        {
                            std::cout&lt;&lt;&quot;zval6[&quot;&lt;&lt;aa&lt;&lt;&quot;]=&quot;&lt;&lt; bb.to_string()&lt;&lt;std::endl;
                        }
                    }
                    std::cout&lt;&lt;std::endl;
                }
            }
            std::cout&lt;&lt;&quot;------&quot;&lt;&lt;std::endl;
        </code></pre>
        <p>主要应用在复杂对象交换程序，如果不是可以使用C++ 内置对象或STL库方式。</p>
    </div>
    <div class="container">
        
        <h3>ORM介绍</h3>
        <p>先在按照安装环境教程导入的数据。</p>
        <p>paozhu框架内置ORM对象，目前自己分析MySQL协议，方便和ORM整合，而且支持协程模式，这个官方没有支持。</p>
        <p>配置文件位置 <code>conf/orm.conf</code></p>
        <pre><code>[default]
        type=main
        host=127.0.0.1
        port=3306
        dbname=hello_world
        user=benchmarkdbuser
        password=benchmarkdbpass
        pretable=
        maxpool=5
        dbtype=mysql
        #ssl=ON
        
        type=second
        host=127.0.0.1
        port=3306
        dbname=hello_world
        user=benchmarkdbuser
        password=benchmarkdbpass
        pretable=
        maxpool=20
        dbtype=mysql
        #ssl=ON
        </code></pre>
    </div>
    <div class="container">
        <h3>ORM 配置</h3>
        <p><code>type</code> 为类型 就是主从分离，以后可以开发缓存同步，目前先主从。host <code>127.0.0.1</code> 填本地的地址，MySQL必须大于等于8版本，因为MySQL9不支持旧的认证了，
        <code>pretable</code> 是表前缀，有时候只有一个数据库权限可以一个数据库放多个业务。
        <code>dbtype</code> 目前支持MySQL。
        <code>ssl</code> 可以打开，特别是远程连接时候，启用加密连接。本地的不会启用ssl连接。</p>
    </div>
    <div class="container">
        <h3>ORM 使用入门</h3>
        <p>框架目前支持数据库到文件方式，这样修改数据库可以重新生成ORM文件。
        编译成功后</p>
        <pre><code># ./bin/paozhu_cli 
        
        paozhu_cli(1495,0x7ff85ac38fc0) malloc: nano zone abandoned due to inability to reserve vm space.
          model ｜ view | viewtocpp | control   
         Welcome to use cli to manage your MVC files。
        (m)model (v)view (f)viewtocpp or (c)control , (j)son ,x or q to exit[input m|v|f|c|j|]:
        </code></pre>
        <p>输入 m 选择生成ORM模型文件</p>
        <pre><code>
        paozhu_cli(1495,0x7ff85ac38fc0) malloc: nano zone abandoned due to inability to reserve vm space.
          model ｜ view | viewtocpp | control   
         Welcome to use cli to manage your MVC files。
        (m)model (v)view (f)viewtocpp or (c)control , (j)son ,x or q to exit[input m|v|f|c|j|]:m   
         🍄 current path: /Users/hzq/paozhu
         1 hello_world
         3 paozhu_docs
         5 cppcms
        select db index:
        </code></pre>
        <p>输入 1 选择 hello_world 数据库生成文件。</p>
        <pre><code>paozhu_cli(1495,0x7ff85ac38fc0) malloc: nano zone abandoned due to inability to reserve vm space.
          model ｜ view | viewtocpp | control   
         Welcome to use cli to manage your MVC files。
        (m)model (v)view (f)viewtocpp or (c)control , (j)son ,x or q to exit[input m|v|f|c|j|]:m
         🍄 current path: /Users/hzq/paozhu
         1 hello_world
         3 paozhu_docs
         5 cppcms
        select db index:1
        show tables;
        create fortune table to models 🚗
         create table metainfo file: /Users/hzq/paozhu/orm/include/fortunebase.h
        create world table to models 🚗
         create table metainfo file: /Users/hzq/paozhu/orm/include/worldbase.h
        (m)model (v)view (f)viewtocpp or (c)control , (j)son ,x or q to exit[input m|v|f|c|j|]:x
        </code></pre>
        <p>输入 x 退出</p>
        <p>可以看到 /Users/hzq/paozhu/orm 目录下生成文件</p>
        <pre><code>
        orm
        ├── include
        │   ├── fortune_mysql.h
        │   ├── fortunebase.h
        │   ├── world_mysql.h
        │   └── worldbase.h
        ├── orm.h
        │
        models
        ├── Fortune.cpp
        ├── World.cpp
        └── include
            ├── Fortune.h
            └── World.h
        </code></pre>
        <p>orm目录是实体文件，两个文件一个是mysql连接层mysql结尾,操作数据库查询接口，一个是数据表实体映射base.h结尾，也是操作查询结果的接口,这个目录文件更新时候会覆盖，因为与数据库表结构一一对应。</p>
        <p>models目录是业务代码文件，我们其实是操作models目录下文件，这两个文件一个cpp一个h文件，自动生成， 但是只生成一次，有了不会覆盖，在自己的项目系统可以加业务代码在里面。</p>
        <p>比如
        auto myworld = orm::World();
        就是 models 目录下 World.h
        这个是默认数据库，比如自带cms演示
        auto users = orm::cms::Sysuser();</p>
        <p>orm是命名空间，主要是给ORM用
        cms是orm.conf数据库配置标签，也是生成的cms命名空间，方便隔离和转换数据库，如果是[default]可以省略default.</p>
        <h3>ORM设计原理</h3>
        <p>为什么这样设计呢，其实也是paozhu框架目前比其它框架非常有特色的设计。</p>
        <ol>
        <li>一个数据库可以有多个连接，这样我们不用知道使用那个连接。</li>
        <li>数据库名字可能很长，像云主机可能自动生成一个几十个字符长的数据库名，甚至有下划线的。</li>
        <li>可以个性标签，这样数据库是什么名不重要了。</li>
        <li>我们用来做命名空间隔离表对象，这样很多数据库生成的C++类不会冲突。</li>
        <li>ORM设计出强大优雅链式写法，Go和Rust设计缺陷无法使用链式写法。</li>
        </ol>
        <p>所以<code>orm::cms::Sysuser();</code>使用cms隔离了<code>sysuser</code>表实体C++类，不会与其它数据库同名表有冲突。
        比如<code>orm::erp::Sysuser();</code> erp是erp数据库标签，他的数据库是什么名不重要，
        就是同样有<code>sysuser</code>表也没有关系。</p>
        <p>之所以这样设计，就是一个业务系统，一个单体服务器程序，可以有很多数据库，而且他们表名可以有重名。
        以后可以有不同数据库，比如MySQL PG等，他们可以分布在其它机器上。
        他们可以混合集群，单体服务器程序也可以集群，因为内置了读写分离，写服务器可以同一个，
        查询可以固定或动态分配数据库服务器,框架可以适合大业务系统。
        目前看一个服务器集成数据库和业务程序为主。</p>
    </div>
    <div class="container">
        <h3>ORM使用例子</h3>
        <p>表模型有两个成员变量很重要</p>
        <ul>
        <li>data     是单个表数据结构映射</li>
        <li>record   一个std::vector数组</li>
        </ul>
        <p>表数据结构</p>
        <pre><code class="language-C++">struct meta{
         unsigned  int  id = 0; 
         int  randomnumber = 0;  
        } data;
        
        std::vector&lt;worldbase::meta&gt; record;
        </code></pre>
        <h4>协程方式使用ORM</h4>
        <pre><code class="language-C++">//@urlpath(null,queries)
        asio::awaitable&lt;std::string&gt; techempowerqueries(std::shared_ptr&lt;httppeer&gt; peer)
        {
            peer-&gt;type(&quot;application/json; charset=UTF-8&quot;);
            peer-&gt;set_header(&quot;Date&quot;, get_gmttime());
        
            unsigned int get_num = peer-&gt;get[&quot;queries&quot;].to_int();
            if (get_num == 0)
            {
                get_num = 1;
            }
            else if (get_num &gt; 500)
            {
                get_num = 500;
            }
            auto myworld = orm::World();
            myworld.record.reserve(get_num);
            myworld.lock_conn();
            for (unsigned int i = 0; i &lt; get_num; i++)
            {
                myworld.wheresql.clear();
                unsigned int rd_num = rand_range(1, 10000);
                myworld.where(&quot;id&quot;, rd_num);
                co_await myworld.async_fetch_append();
            }
            myworld.unlock_conn();
            peer-&gt;output = myworld.to_json();
            co_return &quot;&quot;;
        }
        </code></pre>
        <ul>
        <li><code>orm::World();</code> 是ORM的表模型，默认连接，所以不用default</li>
        <li><code>myworld.lock_conn();</code> 就是固定一个连接，因为使用ORM连接池方式,会轮训使用连接。</li>
        <li><code>myworld.record.reserve(get_num);</code> 扩容这个熟悉STL的知道。</li>
        <li><code>myworld.wheresql.clear();</code> 推荐使<code>myworld.clearWhere();</code>方式清除条件。</li>
        <li><code>myworld.where(&quot;id&quot;, rd_num);</code> 加一个条件。</li>
        <li><code>co_await myworld.async_fetch_append();</code> 是高级用法，会附加数据到record对象上。一般使用<code>co_await myworld.async_fetch();</code> 会清除record对象，然后重新赋值。</li>
        </ul>
        <p><code>peer-&gt;output = myworld.to_json();</code> 直接输出JSON到浏览器。</p>

    </div>
    <div class="container">
        <h4>同步使用ORM</h4>
        <p>正常业务代码在一个线程中运行，就是一个连接一个线程，这个很经典方式。</p>
        <pre><code class="language-C++">//@urlpath(admin_islogin,admin/addtopic)
        std::string admin_addtopic(std::shared_ptr&lt;httppeer&gt; peer)
        {
            httppeer &amp;client = peer-&gt;get_peer();
            try
            {
                auto topicm = orm::cms::Topic();
                topicm.where(&quot;userid&quot;, client.session[&quot;userid&quot;].to_int()).asc(&quot;parentid&quot;).fetch();
        
                client.val[&quot;list&quot;].set_array();
                obj_val temp;
        
                for (unsigned int i = 0; i &lt; topicm.record.size(); i++)
                {
                    temp[&quot;id&quot;]       = topicm.record[i].topicid;
                    temp[&quot;parentid&quot;] = topicm.record[i].parentid;
                    temp[&quot;value&quot;]    = topicm.record[i].title;
                    client.val[&quot;list&quot;].push(temp);
                }
            }
            catch (std::exception &amp;e)
            {
                client.val[&quot;code&quot;] = 1;
            }
        
            peer-&gt;view(&quot;admin/addtopic&quot;);
            return &quot;&quot;;
        }
        </code></pre>


        <p><code>httppeer &amp;client = peer-&gt;get_peer();</code> 引用连接对象</p>
        <p><code>auto topicm = orm::cms::Topic();</code>  产生一个ORM模型，这个模型源文件在models目录下面,Topic就是数据库表名，如果设置前缀那么框架会自动去除，<code>topicm.where</code> 添加查询条件，<code>asc(&quot;parentid&quot;).fetch()</code> 按升序<code>parentid</code>查询，<code>.fetch()</code>发出查询命令。</p>
        <h4>分页使用</h4>
        <p>如果不想要那么多数据可以分页取出，特别是网络业务，需要占用带宽或cpu资源，平时最好按需使用<code>.select(&quot;fieldname1,fieldname2&quot;)</code> 取出字段数据，使用<code>.limit(pos,offset)</code>限定范围。</p>
        <p>使用<code>.page(page, 10, 5)</code>已经自动添加了<code>.limit(pos,offset)</code>限定范围，只要传入<code>page</code>页码。</p>
        <pre><code class="language-C++">auto [bar_min, bar_max, current_page, total_page] = artmodel.page(page, 10, 5);

        client.val[&quot;pageinfo&quot;].set_object();
        client.val[&quot;pageinfo&quot;][&quot;min&quot;]     = bar_min;
        client.val[&quot;pageinfo&quot;][&quot;max&quot;]     = bar_max;
        client.val[&quot;pageinfo&quot;][&quot;current&quot;] = current_page;
        client.val[&quot;pageinfo&quot;][&quot;total&quot;]   = total_page;
        </code></pre>
        <p><code>.page(page, 10, 5)</code> 返回四个数值，<code>bar_min</code> <code>bar_max</code>由传入5决定范围，
        就是前后2页窗口，每页10个，</p>
        <p>ORM where其它方法</p>
        <p><code>whereLike(fieldname,searchword)</code> 其实就是 and fieldname '%searchword%'设置<br />
        <code>whereAnd</code> 其实就是 and fieldname = val 设置<br />
        <code>whereIn</code> 其实就是 and fieldname IN(val) 设置</p>
      </div>

      <div class="container">
        <h3>paozhu 框架view 视图入门</h3>
        <p>paozhu 做为 c++ web framework 框架 就是MVC 模式，现在就是说v 这个视图功能</p>
        <h4>1、视图说明</h4>
        <p>就是给浏览器显示的内容，其实就是HTML内容，类似PHP脚本语言输出，那我们C++怎么操作呢，也是在HTML里面放C++ 代码，然后编译成为C++的.cpp文件，常驻内存，这样速度也很快，几百个视图文件只要几M内存，一个公司项目也就是1000左右页面。估计不到10M内存，如果用脚本语言运行时会还要大量io读取文件。 框架直接编译其为程序，不用io读取了，速度极快。</p>
        <h4>2、创建视图</h4>
        <p>我们在view目录</p>
        <p>创建 login 目录 然后再创建一个login.html文件在login目录里面</p>
        <p>view</p>
        <ul>
        <li>login
        <ul>
        <li>login.html</li>
        </ul>
        </li>
        </ul>
        <p>大概这样子</p>
        <h4>login.html 文件内容</h4>
        <pre><code class="language-html">&lt;!doctype html&gt;
        &lt;html lang=&quot;en&quot;&gt;
          &lt;head&gt;
            &lt;meta charset=&quot;utf-8&quot;&gt;
            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
            &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt;
            &lt;meta name=&quot;author&quot; content=&quot;Mark Otto, Jacob Thornton, and Bootstrap contributors&quot;&gt;
            &lt;meta name=&quot;generator&quot; content=&quot;Hugo 0.101.0&quot;&gt;
            &lt;title&gt;Content Management System&lt;/title&gt;
        
            &lt;link href=&quot;/assets/dist/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;
          &lt;/head&gt;
          &lt;body class=&quot;text-center&quot;&gt;
            &lt;%c include_sub(&quot;home/header&quot;,obj); %&gt;
            &lt;div class=&quot;container text-center&quot;&gt;
              &lt;div class=&quot;row&quot;&gt;
                &lt;div class=&quot;col-3&quot;&gt;&lt;/div&gt;  
                &lt;div class=&quot;col-6&quot;&gt;
                  &lt;h2 id=&quot;horizontal-form&quot;&gt;CMS Admin &lt;/h2&gt;
                  &lt;form action=&quot;/cms/loginpost&quot; method=&quot;post&quot;&gt;
                    &lt;div class=&quot;row mb-3&quot;&gt;
                      &lt;label for=&quot;username&quot; class=&quot;col-sm-2 col-form-label&quot;&gt;Username&lt;/label&gt;
                      &lt;div class=&quot;col-sm-10&quot;&gt;
                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;username&quot; name=&quot;username&quot; value=&quot;admin&quot;&gt;
                      &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class=&quot;row mb-3&quot;&gt;
                      &lt;label for=&quot;password&quot; class=&quot;col-sm-2 col-form-label&quot;&gt;Password&lt;/label&gt;
                      &lt;div class=&quot;col-sm-10&quot;&gt;
                        &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;password&quot; name=&quot;password&quot; value=&quot;123456&quot;&gt;
                      &lt;/div&gt;
                    &lt;/div&gt;
        
                    &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Sign in&lt;/button&gt;
                  &lt;/form&gt;
              
                &lt;/div&gt;
         
              &lt;/div&gt;
            &lt;/div&gt;
        
          &lt;/body&gt;
          &lt;/html&gt;
        
        
        </code></pre>
        <p>include_sub(&quot;home/header&quot;,obj);</p>
        <p>说明还包括一个子页面，我们再在view创建一个子页面目录home</p>
        <p>view</p>
        <ul>
        <li>home
        <ul>
        <li>header.html</li>
        </ul>
        </li>
        <li>login
        <ul>
        <li>login.html</li>
        </ul>
        </li>
        </ul>
        <p>大概这样子</p>
        <h4>header.html 内容其实就是网页头部信息</h4>
        <pre><code class="language-html">
        &lt;style&gt;
          ul {
              list-style-type: none;
              margin: 0;
              padding: 0;
              overflow: hidden;
              background-color: #333;
          }
          
          li {
              float: left;
              border-right:1px solid #bbb;
          }
          
          li:last-child {
              border-right: none;
          }
          
          li a {
              display: block;
              color: white;
              text-align: center;
              padding: 14px 16px;
              text-decoration: none;
          }
          
          li a:hover:not(.active) {
              background-color: #111;
          }
          
          .active {
              background-color: #4CAF50;
          }
          &lt;/style&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;a class=&quot;active&quot; href=&quot;/&quot;&gt;主页&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#news&quot;&gt;新闻&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#contact&quot;&gt;联系&lt;/a&gt;&lt;/li&gt;
          &lt;li style=&quot;float:right&quot;&gt;&lt;a href=&quot;#about&quot;&gt;关于&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
        
        &lt;h3&gt;子页面页面include_sub(&quot;home/header&quot;)导航测试 |&lt;%c echo&lt;&lt;vinfo.get[&quot;aa&quot;].to_string(); %&gt;| &lt;/h3&gt;
             
         
        </code></pre>
        <p>echo&lt;&lt;vinfo.get[&quot;aa&quot;].to_string();</p>
        <p>这个就是 视图标签 c++ 代码用&lt;%c %&gt;包括起来</p>
        <p>echo 是缓冲区，就是跟外面html一起拼起来</p>
        <p>变成c++代码</p>
        <p>是这样子</p>
        <p>echo&lt;&lt;&quot;导航测试 |&quot;;</p>
        <p>echo&lt;&lt;vinfo.get[&quot;aa&quot;].to_string();</p>
        <p>echo&lt;&lt;&quot;| &lt;/h3&gt;&quot;;</p>
        <p>具体可以看viewsrc/view/home/header.cpp代码。</p>
        <h4>3、 编译视图到cpp文件</h4>
        <p>在网站根目录下运行</p>
        <p>./bin/paozhu_cli</p>
        <p>选择f 生成文件</p>
        <pre><code class="language-c++">
        ./bin/paozhu_cli
        ./bin/paozhu_cli  model ｜ view | viewtocpp | control   
         🎉 Welcome to use cli to manage your MVC files。
        (m)model (v)view (f)viewtocpp or (c)control,x or q to exit[input m|v|f|c|]:f
         🍄 current path: /Users/hzq/paozhu
        1 [+] view/home/header.html 	 time: 2022-12-12 13:1:41
        2 [+] view/login/login.html 	 time: 2022-12-12 13:1:26
         please input number to parse to cpp file.
         a update all , example: 1 3 4 5 enter key, q or x to exit,r reload 
         input number:a
        
        </code></pre>
        <p>我们先用f,直接跟框架一起编译的方法。</p>
        <p>然后选择a,所有修改或新建的视图文件都转化为cpp文件</p>
        <p>文件保存在 viewsrc目录</p>
        <p>viewsrc</p>
        <ul>
        <li>
        <p>view</p>
        <ul>
        <li>login
        <ul>
        <li>login.cpp</li>
        </ul>
        </li>
        <li>home
        <ul>
        <li>header.cpp</li>
        </ul>
        </li>
        </ul>
        </li>
        <li>
        <p>include</p>
        <ul>
        <li>viewsrc.h</li>
        <li>regviewmethod.hpp</li>
        </ul>
        </li>
        </ul>
        <p>大概这样</p>
        <p>我们两个 login.html header.html已经转为cpp文件</p>
        <p>include 目录里面两个文件</p>
        <p>viewsrc.h 是所有视图文件函数的定义，以后可能会分开，一个视图文件对一个头文件。</p>
        <p>regviewmethod.hpp 是视图注册函数，框架调用这个注册到框架</p>
        <h4>viewsrc.h 文件内容</h4>
        <pre><code class="language-c++">
        #ifndef __HTTP_VIEWSRC_ALL_METHOD_H
        #define __HTTP_VIEWSRC_ALL_METHOD_H
        
        #if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)
        #pragma once
        #endif // defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)
        
        #include&lt;string&gt;
        #include&lt;map&gt;
        #include&lt;functional&gt;
        #include &quot;request.h&quot;
        #include &quot;viewso_param.h&quot;
        
        namespace http { 
        namespace view { 
        
        namespace home{ 
        
            std::string header(const struct view_param &amp;vinfo,http::obj_val &amp;obj);
        }
        
        namespace login{ 
        
            std::string login(const struct view_param &amp;vinfo,http::obj_val &amp;obj);
        }
        
        
        }
        
        }
        #endif
        
        </code></pre>
        <p>可以看到视图都放在命名空间里面，这样，一个目录里面和其它目录里面视图文件重名也没有冲突。</p>
        <h4>regviewmethod.hpp 注册函数文件</h4>
        <pre><code class="language-c++">
        #ifndef __HTTP_REG_VIEW_METHOD_HPP
        #define __HTTP_REG_VIEW_METHOD_HPP
        
        #if defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)
        #pragma once
        #endif // defined(_MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)
        
        #include&lt;string&gt;
        #include&lt;map&gt;
        #include&lt;functional&gt;
        #include &quot;request.h&quot;
        #include &quot;viewso_param.h&quot;
        #include &quot;viewmethold_reg.h&quot;
        #include &quot;viewsrc.h&quot;
        
        namespace http
        {
          void _initview_method_regto(VIEW_REG  &amp;_viewmetholdreg)
          {
                         //create time: Mon, 12 Dec 2022 05:01:53 GMT
        
            _viewmetholdreg.emplace(&quot;home/header&quot;,http::view::home::header);
            _viewmetholdreg.emplace(&quot;login/login&quot;,http::view::login::login);
        
            } 
        }
        #endif
        
        </code></pre>
        <p>两个函数注册到回调函数上，就是一个视图文件是一个函数</p>
        <p>目录名和文件名 组成一个注册点</p>
        <p>login/login 是一个注册点</p>
        <p>控制器 peer-&gt;view(&quot;login/login&quot;); 调用方法</p>
        <h4>4、 视图测试</h4>
        <p>我们创建完视图，现在测试一下</p>
        <p>按照hello world入门那章</p>
        <p><code>controller/src</code>目录 创建 <code>testview.cpp</code> 文件</p>
        <p>大概这样子</p>
        <h4>testview.cpp</h4>
        <pre><code class="language-c++">#include &lt;chrono&gt;
        #include &lt;thread&gt;
        #include &quot;httppeer.h&quot;
        #include &quot;testview.h&quot;
        namespace http
        {
               //@urlpath(null,testview)
              std::string testloginview(std::shared_ptr&lt;httppeer&gt; peer)
              {
                    httppeer &amp;client = peer-&gt;getpeer();
                    client &lt;&lt; &quot; 视图测试 &quot;;
                    // client &lt;&lt; client.gethosturl();
                    // client&lt;&lt;&quot;&lt;p&gt;&lt;a href=\&quot;&quot;&lt;&lt;client.gethosturl()&lt;&lt;&quot;/showcookie\&quot;&gt;show&lt;/a&gt;&lt;/p&gt;&quot;;
        
                    peer-&gt;view(&quot;login/login&quot;);
                    return &quot;&quot;;
              }
        
        }
        
        </code></pre>
        <p>把 testview 映射到 testloginview 上，两个名字可以不一样。</p>
        <p>就是http://localhost/testview 可以访问我们的testloginview函数</p>
        <h4>5、编译</h4>
        <p>一切准备就绪了，我们开始编译</p>
        <p>回到项目根目录进入build目录</p>
        <p>cmake ..</p>
        <p>make</p>
        <p>然后在回到根目录，或打开新的命令窗口</p>
        <p>执行</p>
        <p>./bin/paozhu #在Linux 使用 sudo ./bin/paozhu </p>
        <p>用浏览器打开</p>
        <p>http://localhost/testview</p>
        <p>可以看到视图内容了</p>

      </div>   
      <div class="container">

        <h3>C++生产环境故障排查</h3>
        <p>框架开启了ASAN，如果在调试时候被ASAN检测到会指出哪一行有问题。</p>
        <p>生产环境因为没有输出原因，难以看到。</p>
        <p>生产环境编译参数是</p>
        <pre><code class="language-shell">mkdir build
        cd build
        cmake .. -DCMAKE_BUILD_TYPE=Release #OR cmake .. -DCMAKE_BUILD_TYPE=Release -DENABLE_GD=ON
        make -j8
        </code></pre>
        <p>需要安装gdb coredumpctl</p>
        <p>框架会隔1分钟左右检查 <code>log</code> 目录是否有<code>restart_server</code>文件</p>
        <p>如果我们需要取现在线程栈样品，可以 <code>touch log/restart_server</code> 这样可以让进程重启</p>
        <p>可以使用<code>pstree -aup</code> 查看进程情况</p>
        <p>如果已经取样，需要分析进程栈情况</p>
        <p>核心coredump查看</p>
        <pre><code>coredumpctl list
        coredumpctl info
        </code></pre>
        <p>直接在线看,1524是 info 显示的进程号，也就是之前<code>pstree -aup</code> 看的</p>
        <pre><code>coredumpctl gdb 1524</code></pre>
        <p><code>bt</code>可以查看</p>
        <p>进去后我们可以保存出来看，保存在当前目前 <code>thread_info.txt</code>文件。</p>
        <pre><code>
        set logging file thread_info.txt
        set logging enabled on
        thread apply all bt
        set logging enabled off
        </code></pre>
        <p>核心coredump一般在</p>
        <pre><code>/var/lib/systemd/coredump
        </code></pre>

        <p>如果编译使用-g 那么会看到类似下面样子，一般会显示各种线程目前正在干什么事</p>

        <pre><code>Thread 17 (Thread 0x7fd9f16b9640 (LWP 10658)):
          #0  http::hash_objkey (key=&quot;data:image/php;base64,PD9waHAgJE8wME9PMD11cmxkZWNvZGUoIiU3OCUzNCU2My&quot;...) at /www/paozhu/vendor/httpserver/src/request.cpp:54
          #1  0x000000000060032f in http::obj_val::operator[] (this=0x7fd9cc01e520, key=&quot;data:image/php;base64,PD9waHAgJE8wME9PMD11cmxkZWNvZGUoIiU3OCUzNCU2MyU2RiUyRiU3MCUzOSU3OSU3MSU2RSU2NCUyRCU2QyU3MiU2QiU2NCU2NyU1RiU&quot;...) at /www/paozhu/vendor/httpserver/src/request.cpp:315
          #2  0x00000000005a990c in http::httpparse::procssxformurlencoded (this=0x7fd9b400d370) at /www/paozhu/vendor/httpserver/src/http_parse.cpp:389
          #3  0x00000000005b1bfa in http::httpparse::process (this=0x7fd9b400d370, buffer=0x2e223c0 &quot;POST /public/static/lib/webuploader/0.1.5/server/preview.php HTTP/1.1\r\nHost: www. paozhu.org\r\nUser-Agent: Mozilla/5.0 AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0\r\nAccept-Encoding: gzip, deflate&quot;..., buffersize=964) at /www/paozhu/vendor/httpserver/src/http_parse.cpp:2823
          </code></pre>
          <p><a href="CMakeLists_debug_product.txt">Reference to CMakeLists.txt</a></p>
    </div>
</body>

</html>