æ¡†æ¶æ”¯æŒè‡ªåŠ¨æ³¨è§£
æ‰€æœ‰handle éƒ½è¦æ”¾åœ¨  controller/src ç›®å½•ä¸‹é¢ï¼Œè¿™æ ·ç¼–è¯‘æ—¶å€™ä¼šè‡ªåŠ¨å¤„ç†æ³¨è§£ã€‚

//@urlpath(null,plaintext)
asio::awaitable<std::string> techempowerplaintext(std::shared_ptr<httppeer> peer)
{
    peer->type("text/plain; charset=UTF-8");
    peer->set_header("Date", get_gmttime());
    peer->output = "Hello, World!";
    co_return "";
}

@urlpath(null,hello)
std::string testhello(std::shared_ptr<httppeer> peer)
{
    httppeer &client = peer->get_peer();
    client << " Hello world! ğŸ§¨ Paozhu c++ web framework ";

    return "";
}

æ¡†æ¶æ”¯æŒåç¨‹æ¨¡å¼å’Œç»å…¸çº¿ç¨‹æ¨¡å¼
asio::awaitable<std::string> æ˜¯åç¨‹æ¨¡å¼ï¼Œä¸ä¼šèµ°çº¿ç¨‹æ± ã€‚
std::string æ˜¯ç»å…¸çº¿ç¨‹æ± æ¨¡å¼ï¼Œå°±æ˜¯ä¸€ä¸ªè¿æ¥å¯¹åº”ä¸€ä¸ªçº¿ç¨‹å¤„ç†ï¼Œè¿™æ ·ä½ å¯ä»¥æ‹¥æœ‰è‡ªå·±çš„çº¿ç¨‹ã€‚å»ºè®®ç¹é‡ä»»åŠ¡ä½¿ç”¨çº¿ç¨‹æ± æ¨¡å¼ã€‚

è¿˜æœ‰æ³¨æ„è¿”å›å€¼ï¼Œæ–°æ‰‹å»ºè®®è¿”å›ç©ºå­—ç¬¦ï¼Œå› ä¸ºç™»å½•æ—¶å€™å¦‚æœæ­£ç¡®å¯ä»¥è¿”å›OK,è¿™æ ·é…åˆæ³¨è§£ã€‚

@urlpath(login,hello) loginå°±æ˜¯éªŒè¯æ³¨å†Œå‡½æ•° è·Ÿhelloä¸€æ ·ã€‚

std::shared_ptr<httppeer> peer æ˜¯httpä¸Šä¸‹æ–‡ï¼Œå°±æ˜¯è¿æ¥å¯¹è±¡ï¼Œå¯ä»¥å–å¾—å½“å‰åŸŸåå¯¹åº”ç›®å½•å’ŒåŸŸåï¼ŒSAASåº”ç”¨å¯ä»¥å–å¾—siteid,groupid

httppeer &client æ˜¯å¼•ç”¨

peer->output æ˜¯è¾“å‡ºstring å°±æ˜¯ä¸€ä¸ªstd::string å˜é‡


å¸¦ORMæ³¨å†Œå‡½æ•°

//@urlpath(null,updates)
asio::awaitable<std::string> techempowerupdates(std::shared_ptr<httppeer> peer)
{
    peer->type("application/json; charset=UTF-8");
    peer->set_header("Date", get_gmttime());
    unsigned int get_num = peer->get["queries"].to_int();

    if (get_num == 0)
    {
        get_num = 1;
    }
    else if (get_num > 500)
    {
        get_num = 500;
    }
    auto myworld = orm::World();
    myworld.record.clear();
    myworld.record.reserve(get_num);
    for (unsigned int i = 0; i < get_num; i++)
    {
        myworld.wheresql.clear();
        myworld.where("id", rand_range(1, 10000));
        co_await myworld.async_fetch_append();
        if (myworld.effect() > 0)
        {
            unsigned int j                 = myworld.record.size() - 1;
            myworld.data.randomnumber      = rand_range(1, 10000);
            myworld.record[j].randomnumber = myworld.data.randomnumber;
            co_await myworld.async_update("randomnumber");
        }
    }
    peer->output = myworld.to_json();
    co_return "";
}

orm::World(); æ˜¯ORMçš„è¡¨æ¨¡å‹ï¼Œé»˜è®¤è¿æ¥ï¼Œæ‰€ä»¥ä¸ç”¨defaul

è¡¨æ¨¡å‹æœ‰ä¸¤ä¸ªæˆå‘˜å˜é‡å¾ˆé‡è¦

data     æ˜¯å•ä¸ªè¡¨æ•°æ®ç»“æ„æ˜ å°„
record   ä¸€ä¸ªstd::vectoræ•°ç»„

è¡¨æ•°æ®ç»“æ„
struct meta{
 unsigned  int  id = 0; 
 int  randomnumber = 0;  
} data;

std::vector<worldbase::meta> record;

æ›´å¤šå‚è€ƒORMæ–‡æ¡£

